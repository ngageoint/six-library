# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_sio_lite')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_sio_lite')
    _sio_lite = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_sio_lite', [dirname(__file__)])
        except ImportError:
            import _sio_lite
            return _sio_lite
        try:
            _mod = imp.load_module('_sio_lite', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _sio_lite = swig_import_helper()
    del swig_import_helper
else:
    import _sio_lite
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

import coda.coda_sys
import coda.coda_io
import coda.coda_except
class FileHeader(_object):
    """Proxy of C++ sio::lite::FileHeader class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileHeader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileHeader, name)
    __repr__ = _swig_repr
    UNSIGNED = _sio_lite.FileHeader_UNSIGNED
    SIGNED = _sio_lite.FileHeader_SIGNED
    FLOAT = _sio_lite.FileHeader_FLOAT
    COMPLEX_UNSIGNED = _sio_lite.FileHeader_COMPLEX_UNSIGNED
    COMPLEX_SIGNED = _sio_lite.FileHeader_COMPLEX_SIGNED
    COMPLEX_FLOAT = _sio_lite.FileHeader_COMPLEX_FLOAT
    N_BYTE_UNSIGNED = _sio_lite.FileHeader_N_BYTE_UNSIGNED
    N_BYTE_SIGNED = _sio_lite.FileHeader_N_BYTE_SIGNED
    BASIC_HEADER_LENGTH = _sio_lite.FileHeader_BASIC_HEADER_LENGTH

    def __init__(self, *args):
        """
        __init__(sio::lite::FileHeader self, int numLines, int numElements, int elementSize, int elementType, int ver=1) -> FileHeader
        __init__(sio::lite::FileHeader self, int numLines, int numElements, int elementSize, int elementType) -> FileHeader
        __init__(sio::lite::FileHeader self) -> FileHeader
        """
        this = _sio_lite.new_FileHeader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _sio_lite.delete_FileHeader
    __del__ = lambda self: None

    def getLength(self) -> "long":
        """getLength(FileHeader self) -> long"""
        return _sio_lite.FileHeader_getLength(self)


    def getNumLines(self) -> "int":
        """getNumLines(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getNumLines(self)


    def setNumLines(self, numLines: 'int') -> "void":
        """setNumLines(FileHeader self, int numLines)"""
        return _sio_lite.FileHeader_setNumLines(self, numLines)


    def getNumElements(self) -> "int":
        """getNumElements(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getNumElements(self)


    def setNumElements(self, numElements: 'int') -> "void":
        """setNumElements(FileHeader self, int numElements)"""
        return _sio_lite.FileHeader_setNumElements(self, numElements)


    def getElementSize(self) -> "int":
        """getElementSize(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getElementSize(self)


    def setElementSize(self, size: 'int') -> "void":
        """setElementSize(FileHeader self, int size)"""
        return _sio_lite.FileHeader_setElementSize(self, size)


    def getElementType(self) -> "int":
        """getElementType(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getElementType(self)


    def setElementType(self, type: 'int') -> "void":
        """setElementType(FileHeader self, int type)"""
        return _sio_lite.FileHeader_setElementType(self, type)


    def getElementTypeAsString(self) -> "std::string":
        """getElementTypeAsString(FileHeader self) -> std::string"""
        return _sio_lite.FileHeader_getElementTypeAsString(self)


    def getVersion(self) -> "int":
        """getVersion(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getVersion(self)


    def setVersion(self, newVersion: 'int') -> "void":
        """setVersion(FileHeader self, int newVersion)"""
        return _sio_lite.FileHeader_setVersion(self, newVersion)


    def idsAreNullTerminated(self) -> "bool":
        """idsAreNullTerminated(FileHeader self) -> bool"""
        return _sio_lite.FileHeader_idsAreNullTerminated(self)


    def setNullTerminationFlag(self, flag: 'bool') -> "void":
        """setNullTerminationFlag(FileHeader self, bool flag)"""
        return _sio_lite.FileHeader_setNullTerminationFlag(self, flag)


    def isDifferentByteOrdering(self) -> "bool":
        """isDifferentByteOrdering(FileHeader self) -> bool"""
        return _sio_lite.FileHeader_isDifferentByteOrdering(self)


    def setIsDifferentByteOrdering(self, isDifferent: 'bool') -> "void":
        """setIsDifferentByteOrdering(FileHeader self, bool isDifferent)"""
        return _sio_lite.FileHeader_setIsDifferentByteOrdering(self, isDifferent)


    def userDataFieldExists(self, key: 'std::string const &') -> "bool":
        """userDataFieldExists(FileHeader self, std::string const & key) -> bool"""
        return _sio_lite.FileHeader_userDataFieldExists(self, key)


    def getAllUserDataFields(self, keys: 'std::vector< std::string > &') -> "void":
        """getAllUserDataFields(FileHeader self, std::vector< std::string > & keys)"""
        return _sio_lite.FileHeader_getAllUserDataFields(self, keys)


    def getNumUserDataFields(self) -> "size_t":
        """getNumUserDataFields(FileHeader self) -> size_t"""
        return _sio_lite.FileHeader_getNumUserDataFields(self)


    def getUserData(self, key: 'std::string const &') -> "std::vector< sys::byte > &":
        """getUserData(FileHeader self, std::string const & key) -> std::vector< sys::byte > &"""
        return _sio_lite.FileHeader_getUserData(self, key)


    def getUserDataSection(self, *args) -> "sio::lite::UserDataDictionary &":
        """
        getUserDataSection(FileHeader self) -> sio::lite::UserDataDictionary const
        getUserDataSection(FileHeader self) -> sio::lite::UserDataDictionary &
        """
        return _sio_lite.FileHeader_getUserDataSection(self, *args)


    def addUserData(self, *args) -> "void":
        """
        addUserData(FileHeader self, std::string const & field, std::string const & data)
        addUserData(FileHeader self, std::string const & field, std::vector< sys::byte > const & data)
        addUserData(FileHeader self, std::string const & field, int data)
        """
        return _sio_lite.FileHeader_addUserData(self, *args)


    def to(self, numBands: 'size_t', os: 'OutputStream') -> "void":
        """to(FileHeader self, size_t numBands, OutputStream os)"""
        return _sio_lite.FileHeader_to(self, numBands, os)

FileHeader_swigregister = _sio_lite.FileHeader_swigregister
FileHeader_swigregister(FileHeader)

class StreamReader(coda.coda_io.InputStream):
    """Proxy of C++ sio::lite::StreamReader class."""

    __swig_setmethods__ = {}
    for _s in [coda.coda_io.InputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamReader, name, value)
    __swig_getmethods__ = {}
    for _s in [coda.coda_io.InputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamReader, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_StreamReader
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(sio::lite::StreamReader self) -> StreamReader
        __init__(sio::lite::StreamReader self, InputStream arg2, bool adopt=False) -> StreamReader
        __init__(sio::lite::StreamReader self, InputStream arg2) -> StreamReader
        """
        this = _sio_lite.new_StreamReader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setInputStream(self, arg2: 'InputStream', adopt: 'bool'=False) -> "void":
        """
        setInputStream(StreamReader self, InputStream arg2, bool adopt=False)
        setInputStream(StreamReader self, InputStream arg2)
        """
        return _sio_lite.StreamReader_setInputStream(self, arg2, adopt)


    def getInputStream(self) -> "io::InputStream *":
        """getInputStream(StreamReader self) -> InputStream"""
        return _sio_lite.StreamReader_getInputStream(self)


    def getHeader(self, *args) -> "sio::lite::FileHeader const *":
        """
        getHeader(StreamReader self) -> FileHeader
        getHeader(StreamReader self) -> FileHeader
        """
        return _sio_lite.StreamReader_getHeader(self, *args)


    def readHeader(self) -> "sio::lite::FileHeader *":
        """readHeader(StreamReader self) -> FileHeader"""
        return _sio_lite.StreamReader_readHeader(self)


    def available(self) -> "sys::Off_T":
        """available(StreamReader self) -> sys::Off_T"""
        return _sio_lite.StreamReader_available(self)


    def read(self, data: 'long long', size: 'long long') -> "sys::SSize_T":
        """read(StreamReader self, long long data, long long size) -> sys::SSize_T"""
        return _sio_lite.StreamReader_read(self, data, size)

StreamReader_swigregister = _sio_lite.StreamReader_swigregister
StreamReader_swigregister(StreamReader)


import numpy

def dtypeFromSioType(elementType, elementSize):
    """
    Convert an SIO type & size to a NumPy dtype
    Complex integer types are not supported
    """
    typeMap = {FileHeader.UNSIGNED: 'uint',
               FileHeader.SIGNED: 'int',
               FileHeader.FLOAT: 'float',
               FileHeader.COMPLEX_FLOAT: 'complex'}

    if not elementType in typeMap:
        raise Exception("Unknown element type: " + str(elementType))

    dtypeStr = "%s%s" % (typeMap[elementType], elementSize * 8)

    return numpy.dtype(dtypeStr)


def sioTypeFromDtype(dtype):
    """
    Convert a NumPy dtype into an SIO type & size
    """
# Handle dtypes, strings, numpy types
    dt = numpy.dtype(dtype)

    kindToType = {'i': FileHeader.SIGNED,
                  'u': FileHeader.UNSIGNED,
                  'f': FileHeader.FLOAT,
                  'c': FileHeader.COMPLEX_FLOAT}

    if not dt.kind in kindToType:
        raise Exception("Unknown element type: " + str(dt.kind))

    return kindToType[dt.kind]


def write(numpyArray, outputPathname, elementType = None):
# Make sure this array is sized properly
    if len(numpyArray.shape) != 2:
        raise Exception("Only 2 dimensional images are supported")
    if elementType is None:
        elementType = numpyArray.dtype

    if type(elementType) != int:
        elementType = sioTypeFromDtype(elementType)

    if not numpyArray.flags['C_CONTIGUOUS']:
        numpyArray = numpy.ascontiguousarray(numpyArray)

    header = FileHeader(numpyArray.shape[0],
                        numpyArray.shape[1],
                        numpyArray.strides[1],
                        elementType);

    pointer, ro = numpyArray.__array_interface__['data']

    if pointer == 0 or pointer == None:
        raise Exception("Attempting to write a NULL image")

    writer = FileWriter(outputPathname)
    writer.write(header, pointer)


def read(inputPathname):
    reader = FileReader(inputPathname)
    header = reader.getHeader()

    elementSize = header.getElementSize()
    dtype = dtypeFromSioType(header.getElementType(), elementSize)

    numpyArray = numpy.empty(shape = (header.getNumLines(),
                                      header.getNumElements()),
                             dtype = dtype)
    pointer, ro = numpyArray.__array_interface__['data']
    reader.read(pointer, numpyArray.shape[0] * numpyArray.shape[1] * elementSize)
    return numpyArray;

# This file is compatible with both classic and new-style classes.


