/* =========================================================================
 * This file is part of six.sidd-c++
 * =========================================================================
 *
 * (C) Copyright 2004 - 2014, MDA Information Systems LLC
 *
 * six.sidd-c++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; If not,
 * see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once
#ifndef __SIX_EXPLOITATION_FEATURES_H__
#define __SIX_EXPLOITATION_FEATURES_H__

#include <types/RgAz.h>
#include <mem/ScopedCopyablePtr.h>
#include <six/Types.h>
#include <six/Init.h>
#include <six/ParameterCollection.h>

#include "six/sidd/Exports.h"

/*!
 *  This file deals with the SIDD data structures for ExploitationFeatures
 *
 */

namespace six
{
namespace sidd
{
/*!
 *  \struct InputROI
 *  \brief SIDD InputROI parameters
 *
 *  The InputROI parameter is used only when
 *  processing from SICD or have a parameter that lists the input source
 */
struct InputROI
{
    InputROI(double nr = 0, double nc = 0, double fr = 0, double fc = 0);

    //!  Extent of ROI
    RowColInt size;

    //!  Starting upper left point
    RowColInt upperLeft;

    //! Equality operator
    bool operator==(const InputROI& rhs) const
    {
        return size == rhs.size && upperLeft == rhs.upperLeft;
    }

    bool operator!=(const InputROI& rhs) const
    {
        return !(*this == rhs);
    }
};

/*!
 *  \struct TxRcvPolarization
 *  \brief Transmit/Receive Polarization parameters
 *
 *  Stores the transmit polarization type and the receive angle
 *  relative to the transmit direction
 */
struct TxRcvPolarization
{
    TxRcvPolarization(PolarizationSequenceType tx,
                      PolarizationSequenceType rcv,
                      double rcvOffset);

    TxRcvPolarization(PolarizationSequenceType tx = PolarizationSequenceType::NOT_SET,
                      PolarizationSequenceType rcv = PolarizationSequenceType::NOT_SET);

    PolarizationSequenceType txPolarization;
    PolarizationSequenceType rcvPolarization;
    double rcvPolarizationOffset;

    /**
     * Optional flag to describe whether this input polarization was used in
     * processing the product.
     *
     * Not used in SIDD 2.0
     */
    BooleanType processed;

    //! Equality operator
    bool operator==(const TxRcvPolarization& rhs) const
    {
        return (txPolarization == rhs.txPolarization &&
            rcvPolarization == rhs.rcvPolarization &&
            rcvPolarizationOffset == rhs.rcvPolarizationOffset &&
            processed == rhs.processed);
    }

    bool operator!=(const TxRcvPolarization& rhs) const
    {
        return !(*this == rhs);
    }
};
/*!
 *  \struct Information
 *  \brief SIDD Information object (in ExploitationFeatures)
 *
 *  General collection information.
 */
struct Information
{
    //!  Constructor.  Sets everything to undefined
    Information();

    //! The name of the sensor
    std::string sensorName;

    /*!
     *  Radar collection mode.  The ModeType
     *  refers to the collection type
     */
    RadarModeType radarMode;

    /*!
     *  (Optional) RadarMode ModeID.  Value dependent on profile
     */
    std::string radarModeID;

    /*!
     *  Collection date and time defined in Coordinated Universal
     *  Time (UTC).  The seconds should be followed by a Z to
     *  indicate UTC.
     */
    DateTime collectionDateTime;

    /*!
     *  (Optional) Date and time defined in local
     *  time, stored as a string
     */
    DateTime localDateTime;

    /*!
     *  The duration of collection (units = seconds)
     */
    double collectionDuration;

    /*!
     *  (Optional) Uniformly-weighted resolution (range and azimuth)
     *  processed in the slant plane.
     */
    types::RgAz<double> resolution;

    /*!
     *  (Optional) ROI representing portion of the input
     *  data used to make the product.
     */
    mem::ScopedCopyablePtr<InputROI> inputROI;

    /*!
     *  (Optional) Transmit polarization type and recieve polarization angle
     *  0.2 - unbounded
     */
    std::vector<mem::ScopedCopyablePtr<TxRcvPolarization> > polarization;

    //! Equality operator
    bool operator==(const Information& rhs) const;
    bool operator!=(const Information& rhs) const
    {
        return !(*this == rhs);
    }
};

/*!
 *  \struct Geometry
 *  \brief SIDD Geometry param
 *
 *  Contains key geometry parameters independent of product processing
 */
struct Geometry
{
    /*!
     *  Clockwise angle from North indicating the ETP line of sight
     *  vector. Range: [0, 360)
     *
     */
    double azimuth;

    /*!
     *  Angle between the ETP at scene center and the range vector
     *  perpendicular to the direction of motion
     *  Range: [0, 90]
     */
    double slope;

    /*!
     *  Angle between range and ground velocity vector at nadir
     *  Range: [-180, 180]
     */
    double squint;

    /*!
     *  Angle between the ETP and the range vector
     *  Range: [0, 90]
     *
     */
    double graze;

    /*!
     *  Angle between the ETP and cross-range vector
     *  Range: [-180, 180]
     *
     */
    double tilt;

    /*!
     *  Angle between velocity vector and radar line-of-sight
     *  Range: [-180, 180]
     *
     */
    double dopplerConeAngle;

    /*!
     *  Exploitation feature extension related to geometry for a single
     *  input image
     */
    six::ParameterCollection extensions;

    //! Constructor, sets angles to Init::undefined<double>()
    Geometry();

    //! Equality operator
    bool operator==(const Geometry& rhs) const;
    bool operator!=(const Geometry& rhs) const
    {
        return !(*this == rhs);
    }
};

/*!
 *  \struct Phenomenology
 *  \brief SIDD Phenomenology
 *
 *  Class containing meta-data for both the geometry and the final
 *  product processing
 *
 */
struct Phenomenology
{
    Phenomenology();

    /*!
     *  Contains angle/mag for vertical objects occluding
     *  radar energy
     *  Range: [-180, 180); changed to [0, 360) in SIDD 3.0
     */
    AngleMagnitude shadow;

    /*!
     *  Contains the angle/mag for the layover of a unit height object
     *  Range: [-180, 180); changed to [0, 360) in SIDD 3.0
     */
    AngleMagnitude layover;

    /*!
     *  Range dependent phenomenon describing the energy from a single
     *  scatterer returned to the radar via more than one path
     *  Range: [-180, 180)
     *
     */
    double multiPath;

    /*!
     *  Counter-clockwise angle from increasing row direction to
     *  ground track at the center of the image
     *  Range: [-180, 180)
     */
    double groundTrack;

    /*!
     *  Exploitation feature extension related to phenomenology for a single
     *  input image
     */
    six::ParameterCollection extensions;

    //! Equality operator
    bool operator==(const Phenomenology& rhs) const
    {
        return (shadow == rhs.shadow && layover == rhs.layover &&
            multiPath == rhs.multiPath && groundTrack == rhs.groundTrack &&
            extensions == rhs.extensions);
    }

    bool operator!=(const Phenomenology& rhs) const
    {
        return !(*this == rhs);
    }
};

/*!
 *  Class containing meta-data associated with Collection data in SIDD.
 *  This is data coming from the input sources (e.g., SICDs)
 *
 */
struct Collection
{
    /*!
     *  Each collection is identified by a unique name.   This
     *  is an attribute to the Collection tag
     */
    std::string identifier;

    /*!
     *  Mandatory general collection information
     */
    Information information;

    /*!
     *  (Optional) Key geometry parameters independent of product
     *  processing
     */
    mem::ScopedCopyablePtr<Geometry> geometry;

    /*!
     *  (Optional) Phenomenology related to both the geometry
     *  and the final product processing
     */
    mem::ScopedCopyablePtr<Phenomenology> phenomenology;

    //! Equality operator
    bool operator==(const Collection& rhs) const
    {
        return (identifier == rhs.identifier && information == rhs.information &&
            geometry == rhs.geometry && phenomenology == rhs.phenomenology);
    }

    bool operator!=(const Collection& rhs) const
    {
        return !(*this == rhs);
    }
};

/*!
 * \struct ProcTxRcvPolarization
 * \brief Processed polarization parameters
 */
struct ProcTxRcvPolarization
{
    PolarizationSequenceType txPolarizationProc;
    PolarizationSequenceType rcvPolarizationProc;
};

/*!
 *  \struct Product
 *  \brief SIDD Product parameters
 *
 *  Metadata about the product, including the resolution and angle
 *  to north
 */
struct SIX_SIDD_API Product
{
    //!  Constructor, everything is undefined
    Product();

    //!  Uniformly-weighted resolution projected into the Earth Tangent Plane.
    RowColDouble resolution;

    /*
     * Ellipticity of the 2D-IPR at the ORP, measured in the Earth Geodetic
     * Tangent Plane (EGTP). Ellipticity is the ratio of the IRP ellipse's
     * major axis to minor axis.
     * New in SIDD 2.0
     */
    double ellipticity;

    /*
     * Describes the processed transmit and receive polarizations for the product
     * New in SIDD 2.0
     */
    std::vector<ProcTxRcvPolarization> polarization;

    /*!
     *  Counter-clockwise angle from increasing row direction to north at
     *  the center of the image
     *  Range: [-180, 180)
     */
    double north;

    /*!
     *  Exploitation feature extension for the end product
     */
    six::ParameterCollection extensions;

    //! Equality operator
    bool operator==(const Product& rhs) const
    {
        return resolution == rhs.resolution &&
            ellipticity == rhs.ellipticity &&
            north == rhs.north &&
            extensions == rhs.extensions;
    }

    bool operator!=(const Product& rhs) const
    {
        return !(*this == rhs);
    }
};

/*!
 *  \struct ExploitationFeatures
 *  \brief SIDD ExploitationFeatures
 *
 *  Class contains SIDD computed meta-data regarding the collections.
 */
struct ExploitationFeatures
{
    //!  Creates a collection object numCollections times
    ExploitationFeatures(size_t numCollections = 0);

    /*!
     *  Meta-data associated with each collection
     */
    std::vector<mem::ScopedCopyablePtr<Collection> > collections;

    /*!
     *  Meta-data associated with the product
     */
    std::vector<Product> product;

    //! Equality operator
    bool operator==(const ExploitationFeatures& rhs) const
    {
        return collections == rhs.collections && product == rhs.product;
    }

    bool operator!=(const ExploitationFeatures& rhs) const
    {
        return !(*this == rhs);
    }
};
}
}

#endif
