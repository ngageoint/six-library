/* =========================================================================
 * This file is part of six.sidd-c++
 * =========================================================================
 *
 * (C) Copyright 2004 - 2014, MDA Information Systems LLC
 *
 * six.sidd-c++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; If not,
 * see <http://www.gnu.org/licenses/>.
 *
 */
#include "six/sidd/ExploitationFeatures.h"

namespace six
{
namespace sidd
{
InputROI::InputROI(double nr, double nc, double fr, double fc) :
    size(static_cast<ptrdiff_t>(nr), static_cast<ptrdiff_t>(nc)),
    upperLeft(static_cast<ptrdiff_t>(fr), static_cast<ptrdiff_t>(fc))
{
}

TxRcvPolarization::TxRcvPolarization(PolarizationSequenceType tx, 
                                     PolarizationSequenceType rcv,
                                     double rcvOffset) :
    txPolarization(tx),
    rcvPolarization(rcv),
    rcvPolarizationOffset(rcvOffset),
    processed(Init::undefined<BooleanType>())
{
}

TxRcvPolarization::TxRcvPolarization(PolarizationSequenceType tx,
                                     PolarizationSequenceType rcv) :
    txPolarization(tx),
    rcvPolarization(rcv),
    rcvPolarizationOffset(Init::undefined<double>()),
    processed(Init::undefined<BooleanType>())
{
}

Information::Information() :
    radarMode(Init::undefined<RadarModeType>()),
    localDateTime(Init::undefined<DateTime>()),
    collectionDuration(Init::undefined<double>()),
    resolution(Init::undefined<types::RgAz<double> >())
{
    //! TODO: Should we set sensorName to SPOTLIGHT?
}

bool Information::operator==(const Information& rhs) const
{
    return (sensorName == rhs.sensorName &&
        radarMode == rhs.radarMode &&
        radarModeID == rhs.radarModeID &&
        collectionDateTime == rhs.collectionDateTime &&
        localDateTime == rhs.localDateTime &&
        collectionDuration == rhs.collectionDuration &&
        resolution == rhs.resolution &&
        inputROI == rhs.inputROI &&
        polarization == rhs.polarization);
}

Geometry::Geometry() :
    azimuth(Init::undefined<double>()),
    slope(Init::undefined<double>()),
    squint(Init::undefined<double>()),
    graze(Init::undefined<double>()),
    tilt(Init::undefined<double>()),
    dopplerConeAngle(Init::undefined<double>())
{
}

bool Geometry::operator==(const Geometry& rhs) const
{
    return (azimuth == rhs.azimuth &&
        slope == rhs.slope &&
        squint == rhs.squint &&
        graze == rhs.graze &&
        tilt == rhs.tilt &&
        extensions == rhs.extensions &&
        dopplerConeAngle == rhs.dopplerConeAngle);
}

Phenomenology::Phenomenology() :
    shadow(Init::undefined<AngleMagnitude>()),
    layover(Init::undefined<AngleMagnitude>()),
    multiPath(Init::undefined<double>()),
    groundTrack(Init::undefined<double>())
{
}

Product::Product() :
    resolution(Init::undefined<RowColDouble>()),
    ellipticity(Init::undefined<double>()),
    north(Init::undefined<double>())
{
}

ExploitationFeatures::ExploitationFeatures(size_t numCollections)
{
    collections.resize(numCollections);

    for (size_t ii = 0; ii < numCollections; ++ii)
    {
        collections[ii].reset(new Collection());
    }
}
}
}
