# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _math_poly
else:
    import _math_poly

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import coda.math_linear
import coda.coda_except
import coda.coda_types
import coda.coda_sys

def new_doubleArray(nelements: "size_t") -> "double *":
    r"""new_doubleArray(size_t nelements) -> double *"""
    return _math_poly.new_doubleArray(nelements)

def delete_doubleArray(ary: "double *") -> "void":
    r"""delete_doubleArray(double * ary)"""
    return _math_poly.delete_doubleArray(ary)

def doubleArray_getitem(ary: "double *", index: "size_t") -> "double":
    r"""doubleArray_getitem(double * ary, size_t index) -> double"""
    return _math_poly.doubleArray_getitem(ary, index)

def doubleArray_setitem(ary: "double *", index: "size_t", value: "double") -> "void":
    r"""doubleArray_setitem(double * ary, size_t index, double value)"""
    return _math_poly.doubleArray_setitem(ary, index, value)

from coda.coda_types import pickle

class Poly1D(object):
    r"""Proxy of C++ math::poly::OneD< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(Poly1D self) -> Poly1D
        __init__(Poly1D self, std_vector_double coef) -> Poly1D
        __init__(Poly1D self, size_t order) -> Poly1D
        __init__(Poly1D self, size_t order, double const * coef) -> Poly1D
        """
        _math_poly.Poly1D_swiginit(self, _math_poly.new_Poly1D(*args))

    def order(self) -> "size_t":
        r"""order(Poly1D self) -> size_t"""
        return _math_poly.Poly1D_order(self)

    def size(self) -> "size_t":
        r"""size(Poly1D self) -> size_t"""
        return _math_poly.Poly1D_size(self)

    def empty(self) -> "bool":
        r"""empty(Poly1D self) -> bool"""
        return _math_poly.Poly1D_empty(self)

    def coeffs(self) -> "std::vector< double,std::allocator< double > > const &":
        r"""coeffs(Poly1D self) -> std_vector_double"""
        return _math_poly.Poly1D_coeffs(self)

    def scaleVariable(self, scale: "double") -> "math::poly::OneD< double >":
        r"""scaleVariable(Poly1D self, double scale) -> Poly1D"""
        return _math_poly.Poly1D_scaleVariable(self, scale)

    def truncateTo(self, order: "size_t") -> "math::poly::OneD< double >":
        r"""truncateTo(Poly1D self, size_t order) -> Poly1D"""
        return _math_poly.Poly1D_truncateTo(self, order)

    def truncateToNonZeros(self, zeroEpsilon: "double"=0.0) -> "math::poly::OneD< double >":
        r"""truncateToNonZeros(Poly1D self, double zeroEpsilon=0.0) -> Poly1D"""
        return _math_poly.Poly1D_truncateToNonZeros(self, zeroEpsilon)

    def transformInput(self, gx: "Poly1D", zeroEpsilon: "double"=0.0) -> "math::poly::OneD< double >":
        r"""transformInput(Poly1D self, Poly1D gx, double zeroEpsilon=0.0) -> Poly1D"""
        return _math_poly.Poly1D_transformInput(self, gx, zeroEpsilon)

    def copyFrom(self, p: "Poly1D") -> "void":
        r"""copyFrom(Poly1D self, Poly1D p)"""
        return _math_poly.Poly1D_copyFrom(self, p)

    def integrate(self, start: "double", end: "double") -> "double":
        r"""integrate(Poly1D self, double start, double end) -> double"""
        return _math_poly.Poly1D_integrate(self, start, end)

    def derivative(self) -> "math::poly::OneD< double >":
        r"""derivative(Poly1D self) -> Poly1D"""
        return _math_poly.Poly1D_derivative(self)

    def velocity(self, x: "double") -> "double":
        r"""velocity(Poly1D self, double x) -> double"""
        return _math_poly.Poly1D_velocity(self, x)

    def acceleration(self, x: "double") -> "double":
        r"""acceleration(Poly1D self, double x) -> double"""
        return _math_poly.Poly1D_acceleration(self, x)

    def __imul__(self, *args) -> "math::poly::OneD< double > &":
        r"""
        __imul__(Poly1D self, double cv) -> Poly1D
        __imul__(Poly1D self, Poly1D p) -> Poly1D
        """
        return _math_poly.Poly1D___imul__(self, *args)

    def __mul__(self, *args) -> "math::poly::OneD< double >":
        r"""
        __mul__(Poly1D self, double cv) -> Poly1D
        __mul__(Poly1D self, Poly1D p) -> Poly1D
        """
        return _math_poly.Poly1D___mul__(self, *args)

    def __iadd__(self, p: "Poly1D") -> "math::poly::OneD< double > &":
        r"""__iadd__(Poly1D self, Poly1D p) -> Poly1D"""
        return _math_poly.Poly1D___iadd__(self, p)

    def __add__(self, p: "Poly1D") -> "math::poly::OneD< double >":
        r"""__add__(Poly1D self, Poly1D p) -> Poly1D"""
        return _math_poly.Poly1D___add__(self, p)

    def __isub__(self, p: "Poly1D") -> "math::poly::OneD< double > &":
        r"""__isub__(Poly1D self, Poly1D p) -> Poly1D"""
        return _math_poly.Poly1D___isub__(self, p)

    def __sub__(self, p: "Poly1D") -> "math::poly::OneD< double >":
        r"""__sub__(Poly1D self, Poly1D p) -> Poly1D"""
        return _math_poly.Poly1D___sub__(self, p)

    def __itruediv__(self, *args):
        return _math_poly.Poly1D___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _math_poly.Poly1D___truediv__(self, *args)
    __div__ = __truediv__



    def power(self, toThe: "size_t") -> "math::poly::OneD< double >":
        r"""power(Poly1D self, size_t toThe) -> Poly1D"""
        return _math_poly.Poly1D_power(self, toThe)

    def __eq__(self, p: "Poly1D") -> "bool":
        r"""__eq__(Poly1D self, Poly1D p) -> bool"""
        return _math_poly.Poly1D___eq__(self, p)

    def __ne__(self, p: "Poly1D") -> "bool":
        r"""__ne__(Poly1D self, Poly1D p) -> bool"""
        return _math_poly.Poly1D___ne__(self, p)

    def __setstate__(self, state):
        """Recursive unpickling method for SWIG-wrapped Poly1D."""
        self.__init__(pickle.loads(state.pop('coeffs')))

    def __getstate__(self):
        """Recursive pickling method for SWIG-wrapped Poly1D."""
    # Create a dictionary of parameters and values
        state = {}

    # Use swig_setmethods to get only data we can set later
        state['coeffs'] = pickle.dumps(self.coeffs())
        return state



    def __getitem__(self, i: "long") -> "double":
        r"""__getitem__(Poly1D self, long i) -> double"""
        return _math_poly.Poly1D___getitem__(self, i)

    def __setitem__(self, i: "long", val: "double") -> "void":
        r"""__setitem__(Poly1D self, long i, double val)"""
        return _math_poly.Poly1D___setitem__(self, i, val)

    def __str__(self) -> "std::string":
        r"""__str__(Poly1D self) -> std::string"""
        return _math_poly.Poly1D___str__(self)

    def __deepcopy__(self, memo: "PyObject *") -> "math::poly::OneD< double >":
        r"""__deepcopy__(Poly1D self, PyObject * memo) -> Poly1D"""
        return _math_poly.Poly1D___deepcopy__(self, memo)

    def __call__(self, *args) -> "PyObject *":
        r"""
        __call__(Poly1D self, double at) -> double
        __call__(Poly1D self, PyObject * input) -> PyObject *
        """
        return _math_poly.Poly1D___call__(self, *args)

    def asArray(self) -> "PyObject *":
        r"""asArray(Poly1D self) -> PyObject *"""
        return _math_poly.Poly1D_asArray(self)

    @staticmethod
    def fromArray(array):
        if array.size == 0:
            return Poly1D()
        return Poly1D(array.tolist())

    __swig_destroy__ = _math_poly.delete_Poly1D

# Register Poly1D in _math_poly:
_math_poly.Poly1D_swigregister(Poly1D)

class Vector3Coefficients(object):
    r"""Proxy of C++ std::vector< math::linear::VectorN< 3,double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(Vector3Coefficients self) -> SwigPyIterator"""
        return _math_poly.Vector3Coefficients_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(Vector3Coefficients self) -> bool"""
        return _math_poly.Vector3Coefficients___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(Vector3Coefficients self) -> bool"""
        return _math_poly.Vector3Coefficients___bool__(self)

    def __len__(self) -> "std::vector< math::linear::VectorN< 3,double > >::size_type":
        r"""__len__(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::size_type"""
        return _math_poly.Vector3Coefficients___len__(self)

    def __getslice__(self, i: "std::vector< math::linear::VectorN< 3,double > >::difference_type", j: "std::vector< math::linear::VectorN< 3,double > >::difference_type") -> "std::vector< math::linear::VectorN< 3,double >,std::allocator< math::linear::VectorN< 3,double > > > *":
        r"""__getslice__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i, std::vector< math::linear::VectorN< 3,double > >::difference_type j) -> Vector3Coefficients"""
        return _math_poly.Vector3Coefficients___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i, std::vector< math::linear::VectorN< 3,double > >::difference_type j)
        __setslice__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i, std::vector< math::linear::VectorN< 3,double > >::difference_type j, Vector3Coefficients v)
        """
        return _math_poly.Vector3Coefficients___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< math::linear::VectorN< 3,double > >::difference_type", j: "std::vector< math::linear::VectorN< 3,double > >::difference_type") -> "void":
        r"""__delslice__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i, std::vector< math::linear::VectorN< 3,double > >::difference_type j)"""
        return _math_poly.Vector3Coefficients___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i)
        __delitem__(Vector3Coefficients self, PySliceObject * slice)
        """
        return _math_poly.Vector3Coefficients___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< math::linear::VectorN< 3,double > >::value_type const &":
        r"""
        __getitem__(Vector3Coefficients self, PySliceObject * slice) -> Vector3Coefficients
        __getitem__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i) -> Vector3
        """
        return _math_poly.Vector3Coefficients___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(Vector3Coefficients self, PySliceObject * slice, Vector3Coefficients v)
        __setitem__(Vector3Coefficients self, PySliceObject * slice)
        __setitem__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::difference_type i, Vector3 x)
        """
        return _math_poly.Vector3Coefficients___setitem__(self, *args)

    def pop(self) -> "std::vector< math::linear::VectorN< 3,double > >::value_type":
        r"""pop(Vector3Coefficients self) -> Vector3"""
        return _math_poly.Vector3Coefficients_pop(self)

    def append(self, x: "Vector3") -> "void":
        r"""append(Vector3Coefficients self, Vector3 x)"""
        return _math_poly.Vector3Coefficients_append(self, x)

    def empty(self) -> "bool":
        r"""empty(Vector3Coefficients self) -> bool"""
        return _math_poly.Vector3Coefficients_empty(self)

    def size(self) -> "std::vector< math::linear::VectorN< 3,double > >::size_type":
        r"""size(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::size_type"""
        return _math_poly.Vector3Coefficients_size(self)

    def swap(self, v: "Vector3Coefficients") -> "void":
        r"""swap(Vector3Coefficients self, Vector3Coefficients v)"""
        return _math_poly.Vector3Coefficients_swap(self, v)

    def begin(self) -> "std::vector< math::linear::VectorN< 3,double > >::iterator":
        r"""begin(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::iterator"""
        return _math_poly.Vector3Coefficients_begin(self)

    def end(self) -> "std::vector< math::linear::VectorN< 3,double > >::iterator":
        r"""end(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::iterator"""
        return _math_poly.Vector3Coefficients_end(self)

    def rbegin(self) -> "std::vector< math::linear::VectorN< 3,double > >::reverse_iterator":
        r"""rbegin(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::reverse_iterator"""
        return _math_poly.Vector3Coefficients_rbegin(self)

    def rend(self) -> "std::vector< math::linear::VectorN< 3,double > >::reverse_iterator":
        r"""rend(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::reverse_iterator"""
        return _math_poly.Vector3Coefficients_rend(self)

    def clear(self) -> "void":
        r"""clear(Vector3Coefficients self)"""
        return _math_poly.Vector3Coefficients_clear(self)

    def get_allocator(self) -> "std::vector< math::linear::VectorN< 3,double > >::allocator_type":
        r"""get_allocator(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::allocator_type"""
        return _math_poly.Vector3Coefficients_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(Vector3Coefficients self)"""
        return _math_poly.Vector3Coefficients_pop_back(self)

    def erase(self, *args) -> "std::vector< math::linear::VectorN< 3,double > >::iterator":
        r"""
        erase(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::iterator pos) -> std::vector< math::linear::VectorN< 3,double > >::iterator
        erase(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::iterator first, std::vector< math::linear::VectorN< 3,double > >::iterator last) -> std::vector< math::linear::VectorN< 3,double > >::iterator
        """
        return _math_poly.Vector3Coefficients_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Vector3Coefficients self) -> Vector3Coefficients
        __init__(Vector3Coefficients self, Vector3Coefficients other) -> Vector3Coefficients
        __init__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::size_type size) -> Vector3Coefficients
        __init__(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::size_type size, Vector3 value) -> Vector3Coefficients
        """
        _math_poly.Vector3Coefficients_swiginit(self, _math_poly.new_Vector3Coefficients(*args))

    def push_back(self, x: "Vector3") -> "void":
        r"""push_back(Vector3Coefficients self, Vector3 x)"""
        return _math_poly.Vector3Coefficients_push_back(self, x)

    def front(self) -> "std::vector< math::linear::VectorN< 3,double > >::value_type const &":
        r"""front(Vector3Coefficients self) -> Vector3"""
        return _math_poly.Vector3Coefficients_front(self)

    def back(self) -> "std::vector< math::linear::VectorN< 3,double > >::value_type const &":
        r"""back(Vector3Coefficients self) -> Vector3"""
        return _math_poly.Vector3Coefficients_back(self)

    def assign(self, n: "std::vector< math::linear::VectorN< 3,double > >::size_type", x: "Vector3") -> "void":
        r"""assign(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::size_type n, Vector3 x)"""
        return _math_poly.Vector3Coefficients_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::size_type new_size)
        resize(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::size_type new_size, Vector3 x)
        """
        return _math_poly.Vector3Coefficients_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::iterator pos, Vector3 x) -> std::vector< math::linear::VectorN< 3,double > >::iterator
        insert(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::iterator pos, std::vector< math::linear::VectorN< 3,double > >::size_type n, Vector3 x)
        """
        return _math_poly.Vector3Coefficients_insert(self, *args)

    def reserve(self, n: "std::vector< math::linear::VectorN< 3,double > >::size_type") -> "void":
        r"""reserve(Vector3Coefficients self, std::vector< math::linear::VectorN< 3,double > >::size_type n)"""
        return _math_poly.Vector3Coefficients_reserve(self, n)

    def capacity(self) -> "std::vector< math::linear::VectorN< 3,double > >::size_type":
        r"""capacity(Vector3Coefficients self) -> std::vector< math::linear::VectorN< 3,double > >::size_type"""
        return _math_poly.Vector3Coefficients_capacity(self)

    def __getstate__(self):
    # Return a nonempty (thus non-false) tuple with dummy value in first position
        return (-1, tuple(pickle.dumps(elem) for elem in self))

    def __setstate__(self, state):
        self.__init__()
    # State will have a dummy entry in the first position
        for elem in state[1]:
            self.push_back(pickle.loads(elem))

    __swig_destroy__ = _math_poly.delete_Vector3Coefficients

# Register Vector3Coefficients in _math_poly:
_math_poly.Vector3Coefficients_swigregister(Vector3Coefficients)

class Poly2D(object):
    r"""Proxy of C++ math::poly::TwoD< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def coeffs(self) -> "std::vector< math::poly::OneD< double >,std::allocator< math::poly::OneD< double > > > &":
        r"""coeffs(Poly2D self) -> Poly1DVector"""
        return _math_poly.Poly2D_coeffs(self)

    def __init__(self, *args):
        r"""
        __init__(Poly2D self) -> Poly2D
        __init__(Poly2D self, size_t orderX, size_t orderY) -> Poly2D
        __init__(Poly2D self, Poly1DVector v) -> Poly2D
        """
        _math_poly.Poly2D_swiginit(self, _math_poly.new_Poly2D(*args))

    def empty(self) -> "bool":
        r"""empty(Poly2D self) -> bool"""
        return _math_poly.Poly2D_empty(self)

    def orderX(self) -> "size_t":
        r"""orderX(Poly2D self) -> size_t"""
        return _math_poly.Poly2D_orderX(self)

    def orderY(self) -> "size_t":
        r"""orderY(Poly2D self) -> size_t"""
        return _math_poly.Poly2D_orderY(self)

    def integrate(self, xStart: "double", xEnd: "double", yStart: "double", yEnd: "double") -> "double":
        r"""integrate(Poly2D self, double xStart, double xEnd, double yStart, double yEnd) -> double"""
        return _math_poly.Poly2D_integrate(self, xStart, xEnd, yStart, yEnd)

    def set(self, i: "size_t", p: "Poly1D") -> "void":
        r"""set(Poly2D self, size_t i, Poly1D p)"""
        return _math_poly.Poly2D_set(self, i, p)

    def flipXY(self) -> "math::poly::TwoD< double >":
        r"""flipXY(Poly2D self) -> Poly2D"""
        return _math_poly.Poly2D_flipXY(self)

    def derivativeY(self) -> "math::poly::TwoD< double >":
        r"""derivativeY(Poly2D self) -> Poly2D"""
        return _math_poly.Poly2D_derivativeY(self)

    def derivativeX(self) -> "math::poly::TwoD< double >":
        r"""derivativeX(Poly2D self) -> Poly2D"""
        return _math_poly.Poly2D_derivativeX(self)

    def derivativeXY(self) -> "math::poly::TwoD< double >":
        r"""derivativeXY(Poly2D self) -> Poly2D"""
        return _math_poly.Poly2D_derivativeXY(self)

    def scaleVariable(self, *args) -> "math::poly::TwoD< double >":
        r"""
        scaleVariable(Poly2D self, double scaleX, double scaleY) -> Poly2D
        scaleVariable(Poly2D self, double scale) -> Poly2D
        """
        return _math_poly.Poly2D_scaleVariable(self, *args)

    def truncateTo(self, orderX: "size_t", orderY: "size_t") -> "math::poly::TwoD< double >":
        r"""truncateTo(Poly2D self, size_t orderX, size_t orderY) -> Poly2D"""
        return _math_poly.Poly2D_truncateTo(self, orderX, orderY)

    def truncateToNonZeros(self, zeroEpsilon: "double"=0.0) -> "math::poly::TwoD< double >":
        r"""truncateToNonZeros(Poly2D self, double zeroEpsilon=0.0) -> Poly2D"""
        return _math_poly.Poly2D_truncateToNonZeros(self, zeroEpsilon)

    def transformInput(self, *args) -> "math::poly::TwoD< double >":
        r"""
        transformInput(Poly2D self, Poly2D gx, Poly2D gy, double zeroEpsilon=0.0) -> Poly2D
        transformInput(Poly2D self, Poly2D gx, double zeroEpsilon=0.0) -> Poly2D
        """
        return _math_poly.Poly2D_transformInput(self, *args)

    def atY(self, y: "double") -> "math::poly::OneD< double >":
        r"""atY(Poly2D self, double y) -> Poly1D"""
        return _math_poly.Poly2D_atY(self, y)

    def __imul__(self, *args) -> "math::poly::TwoD< double > &":
        r"""
        __imul__(Poly2D self, double cv) -> Poly2D
        __imul__(Poly2D self, Poly2D p) -> Poly2D
        """
        return _math_poly.Poly2D___imul__(self, *args)

    def __mul__(self, *args) -> "math::poly::TwoD< double >":
        r"""
        __mul__(Poly2D self, double cv) -> Poly2D
        __mul__(Poly2D self, Poly2D p) -> Poly2D
        """
        return _math_poly.Poly2D___mul__(self, *args)

    def __iadd__(self, p: "Poly2D") -> "math::poly::TwoD< double > &":
        r"""__iadd__(Poly2D self, Poly2D p) -> Poly2D"""
        return _math_poly.Poly2D___iadd__(self, p)

    def __add__(self, p: "Poly2D") -> "math::poly::TwoD< double >":
        r"""__add__(Poly2D self, Poly2D p) -> Poly2D"""
        return _math_poly.Poly2D___add__(self, p)

    def __isub__(self, p: "Poly2D") -> "math::poly::TwoD< double > &":
        r"""__isub__(Poly2D self, Poly2D p) -> Poly2D"""
        return _math_poly.Poly2D___isub__(self, p)

    def __sub__(self, p: "Poly2D") -> "math::poly::TwoD< double >":
        r"""__sub__(Poly2D self, Poly2D p) -> Poly2D"""
        return _math_poly.Poly2D___sub__(self, p)

    def __itruediv__(self, *args):
        return _math_poly.Poly2D___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _math_poly.Poly2D___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, p: "Poly2D") -> "bool":
        r"""__eq__(Poly2D self, Poly2D p) -> bool"""
        return _math_poly.Poly2D___eq__(self, p)

    def __ne__(self, p: "Poly2D") -> "bool":
        r"""__ne__(Poly2D self, Poly2D p) -> bool"""
        return _math_poly.Poly2D___ne__(self, p)

    def power(self, toThe: "size_t") -> "math::poly::TwoD< double >":
        r"""power(Poly2D self, size_t toThe) -> Poly2D"""
        return _math_poly.Poly2D_power(self, toThe)

    def isScalar(self) -> "bool":
        r"""isScalar(Poly2D self) -> bool"""
        return _math_poly.Poly2D_isScalar(self)

    def __setstate__(self, state):
        """Recursive unpickling method for SWIG-wrapped Poly2D."""
        self.__init__(pickle.loads(state.pop('coeffs')))

    def __getstate__(self):
        """Recursive pickling method for SWIG-wrapped Poly2D."""
    # Create a dictionary of parameters and values
        state = {}

    # Use swig_setmethods to get only data we can set later
        state['coeffs'] = pickle.dumps(self.coeffs())
        return state


    def __getitem__(self, inObj: "PyObject *") -> "double":
        r"""__getitem__(Poly2D self, PyObject * inObj) -> double"""
        return _math_poly.Poly2D___getitem__(self, inObj)

    def __setitem__(self, inObj: "PyObject *", val: "double") -> "void":
        r"""__setitem__(Poly2D self, PyObject * inObj, double val)"""
        return _math_poly.Poly2D___setitem__(self, inObj, val)

    def __str__(self) -> "std::string":
        r"""__str__(Poly2D self) -> std::string"""
        return _math_poly.Poly2D___str__(self)

    def __deepcopy__(self, memo: "PyObject *") -> "math::poly::TwoD< double >":
        r"""__deepcopy__(Poly2D self, PyObject * memo) -> Poly2D"""
        return _math_poly.Poly2D___deepcopy__(self, memo)

    def __call__(self, *args) -> "PyObject *":
        r"""
        __call__(Poly2D self, double atX, double atY) -> double
        __call__(Poly2D self, PyObject * x_input, PyObject * y_input) -> PyObject *
        """
        return _math_poly.Poly2D___call__(self, *args)

    def asArray(self) -> "PyObject *":
        r"""asArray(Poly2D self) -> PyObject *"""
        return _math_poly.Poly2D_asArray(self)

    @staticmethod
    def fromArray(array):
        if len(array) == 0:
            return Poly2D()
        twoD = Poly2D(array.shape[0] - 1, array.shape[1] - 1)
        for i in range(len(array)):
            for j in range(len(array[0])):
                twoD[(i,j)] = array[i][j]
        return twoD

    __swig_destroy__ = _math_poly.delete_Poly2D

# Register Poly2D in _math_poly:
_math_poly.Poly2D_swigregister(Poly2D)

class Poly1DVector(object):
    r"""Proxy of C++ std::vector< math::poly::OneD< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(Poly1DVector self) -> SwigPyIterator"""
        return _math_poly.Poly1DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(Poly1DVector self) -> bool"""
        return _math_poly.Poly1DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(Poly1DVector self) -> bool"""
        return _math_poly.Poly1DVector___bool__(self)

    def __len__(self) -> "std::vector< math::poly::OneD< double > >::size_type":
        r"""__len__(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::size_type"""
        return _math_poly.Poly1DVector___len__(self)

    def __getslice__(self, i: "std::vector< math::poly::OneD< double > >::difference_type", j: "std::vector< math::poly::OneD< double > >::difference_type") -> "std::vector< math::poly::OneD< double >,std::allocator< math::poly::OneD< double > > > *":
        r"""__getslice__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i, std::vector< math::poly::OneD< double > >::difference_type j) -> Poly1DVector"""
        return _math_poly.Poly1DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i, std::vector< math::poly::OneD< double > >::difference_type j)
        __setslice__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i, std::vector< math::poly::OneD< double > >::difference_type j, Poly1DVector v)
        """
        return _math_poly.Poly1DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< math::poly::OneD< double > >::difference_type", j: "std::vector< math::poly::OneD< double > >::difference_type") -> "void":
        r"""__delslice__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i, std::vector< math::poly::OneD< double > >::difference_type j)"""
        return _math_poly.Poly1DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i)
        __delitem__(Poly1DVector self, PySliceObject * slice)
        """
        return _math_poly.Poly1DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< math::poly::OneD< double > >::value_type const &":
        r"""
        __getitem__(Poly1DVector self, PySliceObject * slice) -> Poly1DVector
        __getitem__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i) -> Poly1D
        """
        return _math_poly.Poly1DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(Poly1DVector self, PySliceObject * slice, Poly1DVector v)
        __setitem__(Poly1DVector self, PySliceObject * slice)
        __setitem__(Poly1DVector self, std::vector< math::poly::OneD< double > >::difference_type i, Poly1D x)
        """
        return _math_poly.Poly1DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< math::poly::OneD< double > >::value_type":
        r"""pop(Poly1DVector self) -> Poly1D"""
        return _math_poly.Poly1DVector_pop(self)

    def append(self, x: "Poly1D") -> "void":
        r"""append(Poly1DVector self, Poly1D x)"""
        return _math_poly.Poly1DVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(Poly1DVector self) -> bool"""
        return _math_poly.Poly1DVector_empty(self)

    def size(self) -> "std::vector< math::poly::OneD< double > >::size_type":
        r"""size(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::size_type"""
        return _math_poly.Poly1DVector_size(self)

    def swap(self, v: "Poly1DVector") -> "void":
        r"""swap(Poly1DVector self, Poly1DVector v)"""
        return _math_poly.Poly1DVector_swap(self, v)

    def begin(self) -> "std::vector< math::poly::OneD< double > >::iterator":
        r"""begin(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::iterator"""
        return _math_poly.Poly1DVector_begin(self)

    def end(self) -> "std::vector< math::poly::OneD< double > >::iterator":
        r"""end(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::iterator"""
        return _math_poly.Poly1DVector_end(self)

    def rbegin(self) -> "std::vector< math::poly::OneD< double > >::reverse_iterator":
        r"""rbegin(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::reverse_iterator"""
        return _math_poly.Poly1DVector_rbegin(self)

    def rend(self) -> "std::vector< math::poly::OneD< double > >::reverse_iterator":
        r"""rend(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::reverse_iterator"""
        return _math_poly.Poly1DVector_rend(self)

    def clear(self) -> "void":
        r"""clear(Poly1DVector self)"""
        return _math_poly.Poly1DVector_clear(self)

    def get_allocator(self) -> "std::vector< math::poly::OneD< double > >::allocator_type":
        r"""get_allocator(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::allocator_type"""
        return _math_poly.Poly1DVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(Poly1DVector self)"""
        return _math_poly.Poly1DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< math::poly::OneD< double > >::iterator":
        r"""
        erase(Poly1DVector self, std::vector< math::poly::OneD< double > >::iterator pos) -> std::vector< math::poly::OneD< double > >::iterator
        erase(Poly1DVector self, std::vector< math::poly::OneD< double > >::iterator first, std::vector< math::poly::OneD< double > >::iterator last) -> std::vector< math::poly::OneD< double > >::iterator
        """
        return _math_poly.Poly1DVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Poly1DVector self) -> Poly1DVector
        __init__(Poly1DVector self, Poly1DVector other) -> Poly1DVector
        __init__(Poly1DVector self, std::vector< math::poly::OneD< double > >::size_type size) -> Poly1DVector
        __init__(Poly1DVector self, std::vector< math::poly::OneD< double > >::size_type size, Poly1D value) -> Poly1DVector
        """
        _math_poly.Poly1DVector_swiginit(self, _math_poly.new_Poly1DVector(*args))

    def push_back(self, x: "Poly1D") -> "void":
        r"""push_back(Poly1DVector self, Poly1D x)"""
        return _math_poly.Poly1DVector_push_back(self, x)

    def front(self) -> "std::vector< math::poly::OneD< double > >::value_type const &":
        r"""front(Poly1DVector self) -> Poly1D"""
        return _math_poly.Poly1DVector_front(self)

    def back(self) -> "std::vector< math::poly::OneD< double > >::value_type const &":
        r"""back(Poly1DVector self) -> Poly1D"""
        return _math_poly.Poly1DVector_back(self)

    def assign(self, n: "std::vector< math::poly::OneD< double > >::size_type", x: "Poly1D") -> "void":
        r"""assign(Poly1DVector self, std::vector< math::poly::OneD< double > >::size_type n, Poly1D x)"""
        return _math_poly.Poly1DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(Poly1DVector self, std::vector< math::poly::OneD< double > >::size_type new_size)
        resize(Poly1DVector self, std::vector< math::poly::OneD< double > >::size_type new_size, Poly1D x)
        """
        return _math_poly.Poly1DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(Poly1DVector self, std::vector< math::poly::OneD< double > >::iterator pos, Poly1D x) -> std::vector< math::poly::OneD< double > >::iterator
        insert(Poly1DVector self, std::vector< math::poly::OneD< double > >::iterator pos, std::vector< math::poly::OneD< double > >::size_type n, Poly1D x)
        """
        return _math_poly.Poly1DVector_insert(self, *args)

    def reserve(self, n: "std::vector< math::poly::OneD< double > >::size_type") -> "void":
        r"""reserve(Poly1DVector self, std::vector< math::poly::OneD< double > >::size_type n)"""
        return _math_poly.Poly1DVector_reserve(self, n)

    def capacity(self) -> "std::vector< math::poly::OneD< double > >::size_type":
        r"""capacity(Poly1DVector self) -> std::vector< math::poly::OneD< double > >::size_type"""
        return _math_poly.Poly1DVector_capacity(self)

    def __getstate__(self):
    # Return a nonempty (thus non-false) tuple with dummy value in first position
        return (-1, tuple(pickle.dumps(elem) for elem in self))

    def __setstate__(self, state):
        self.__init__()
    # State will have a dummy entry in the first position
        for elem in state[1]:
            self.push_back(pickle.loads(elem))

    __swig_destroy__ = _math_poly.delete_Poly1DVector

# Register Poly1DVector in _math_poly:
_math_poly.Poly1DVector_swigregister(Poly1DVector)


def compute_mean_value(*args) -> "double":
    r"""
    compute_mean_value(VectorDouble x) -> double
    compute_mean_value(MatrixDouble x) -> double
    """
    return _math_poly.compute_mean_value(*args)

def fit(*args) -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
    r"""
    fit(size_t numObs, double const * x, double const * y, size_t order) -> Poly1D
    fit(MatrixDouble x, MatrixDouble y, MatrixDouble z, size_t nx, size_t ny) -> Poly2D
    fit(size_t numRows, size_t numCols, double const * x, double const * y, double const * z, size_t nx, size_t ny) -> Poly2D
    fit(VectorDouble xObs, VectorDouble yObs0, VectorDouble yObs1, VectorDouble yObs2, size_t order) -> PolyVector3
    fit(VectorDouble xObsVector, MatrixDouble yObsMatrix, size_t order) -> PolyVector3
    fit(std_vector_double xObs, std_vector_double yObs0, std_vector_double yObs1, std_vector_double yObs2, size_t order) -> PolyVector3
    """
    return _math_poly.fit(*args)

def FitVectorDouble(x: "VectorDouble", y: "VectorDouble", order: "size_t") -> "math::poly::OneD< double >":
    r"""FitVectorDouble(VectorDouble x, VectorDouble y, size_t order) -> Poly1D"""
    return _math_poly.FitVectorDouble(x, y, order)
class PolyVector3(object):
    r"""Proxy of C++ math::poly::OneD< Vector3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PolyVector3 self) -> PolyVector3
        __init__(PolyVector3 self, Vector3Coefficients coef) -> PolyVector3
        __init__(PolyVector3 self, size_t order) -> PolyVector3
        __init__(PolyVector3 self, size_t order, Vector3 coef) -> PolyVector3
        """
        _math_poly.PolyVector3_swiginit(self, _math_poly.new_PolyVector3(*args))

    def order(self) -> "size_t":
        r"""order(PolyVector3 self) -> size_t"""
        return _math_poly.PolyVector3_order(self)

    def size(self) -> "size_t":
        r"""size(PolyVector3 self) -> size_t"""
        return _math_poly.PolyVector3_size(self)

    def empty(self) -> "bool":
        r"""empty(PolyVector3 self) -> bool"""
        return _math_poly.PolyVector3_empty(self)

    def coeffs(self) -> "std::vector< math::linear::VectorN< 3,double >,std::allocator< math::linear::VectorN< 3,double > > > const &":
        r"""coeffs(PolyVector3 self) -> Vector3Coefficients"""
        return _math_poly.PolyVector3_coeffs(self)

    def scaleVariable(self, scale: "double") -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
        r"""scaleVariable(PolyVector3 self, double scale) -> PolyVector3"""
        return _math_poly.PolyVector3_scaleVariable(self, scale)

    def truncateTo(self, order: "size_t") -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
        r"""truncateTo(PolyVector3 self, size_t order) -> PolyVector3"""
        return _math_poly.PolyVector3_truncateTo(self, order)

    def copyFrom(self, p: "PolyVector3") -> "void":
        r"""copyFrom(PolyVector3 self, PolyVector3 p)"""
        return _math_poly.PolyVector3_copyFrom(self, p)

    def derivative(self) -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
        r"""derivative(PolyVector3 self) -> PolyVector3"""
        return _math_poly.PolyVector3_derivative(self)

    def velocity(self, x: "double") -> "math::linear::VectorN< 3,double >":
        r"""velocity(PolyVector3 self, double x) -> Vector3"""
        return _math_poly.PolyVector3_velocity(self, x)

    def acceleration(self, x: "double") -> "math::linear::VectorN< 3,double >":
        r"""acceleration(PolyVector3 self, double x) -> Vector3"""
        return _math_poly.PolyVector3_acceleration(self, x)

    def __imul__(self, *args) -> "math::poly::OneD< math::linear::VectorN< 3,double > > &":
        r"""
        __imul__(PolyVector3 self, double cv) -> PolyVector3
        __imul__(PolyVector3 self, PolyVector3 p) -> PolyVector3
        """
        return _math_poly.PolyVector3___imul__(self, *args)

    def __mul__(self, *args) -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
        r"""
        __mul__(PolyVector3 self, double cv) -> PolyVector3
        __mul__(PolyVector3 self, PolyVector3 p) -> PolyVector3
        """
        return _math_poly.PolyVector3___mul__(self, *args)

    def __iadd__(self, p: "PolyVector3") -> "math::poly::OneD< math::linear::VectorN< 3,double > > &":
        r"""__iadd__(PolyVector3 self, PolyVector3 p) -> PolyVector3"""
        return _math_poly.PolyVector3___iadd__(self, p)

    def __add__(self, p: "PolyVector3") -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
        r"""__add__(PolyVector3 self, PolyVector3 p) -> PolyVector3"""
        return _math_poly.PolyVector3___add__(self, p)

    def __isub__(self, p: "PolyVector3") -> "math::poly::OneD< math::linear::VectorN< 3,double > > &":
        r"""__isub__(PolyVector3 self, PolyVector3 p) -> PolyVector3"""
        return _math_poly.PolyVector3___isub__(self, p)

    def __sub__(self, p: "PolyVector3") -> "math::poly::OneD< math::linear::VectorN< 3,double > >":
        r"""__sub__(PolyVector3 self, PolyVector3 p) -> PolyVector3"""
        return _math_poly.PolyVector3___sub__(self, p)

    def __itruediv__(self, *args):
        return _math_poly.PolyVector3___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _math_poly.PolyVector3___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, p: "PolyVector3") -> "bool":
        r"""__eq__(PolyVector3 self, PolyVector3 p) -> bool"""
        return _math_poly.PolyVector3___eq__(self, p)

    def __ne__(self, p: "PolyVector3") -> "bool":
        r"""__ne__(PolyVector3 self, PolyVector3 p) -> bool"""
        return _math_poly.PolyVector3___ne__(self, p)

    def __setstate__(self, state):
        """Recursive unpickling method for SWIG-wrapped Poly1D."""
        self.__init__(pickle.loads(state.pop('coeffs')))

    def __getstate__(self):
        """Recursive pickling method for SWIG-wrapped Poly1D."""
    # Create a dictionary of parameters and values
        state = {}

    # Use swig_setmethods to get only data we can set later
        state['coeffs'] = pickle.dumps(self.coeffs())
        return state



    def __getitem__(self, i: "long") -> "Vector3":
        r"""__getitem__(PolyVector3 self, long i) -> Vector3"""
        return _math_poly.PolyVector3___getitem__(self, i)

    def __setitem__(self, i: "long", val: "Vector3") -> "void":
        r"""__setitem__(PolyVector3 self, long i, Vector3 val)"""
        return _math_poly.PolyVector3___setitem__(self, i, val)

    def __str__(self) -> "std::string":
        r"""__str__(PolyVector3 self) -> std::string"""
        return _math_poly.PolyVector3___str__(self)

    def __deepcopy__(self, memo: "PyObject *") -> "math::poly::OneD< Vector3 >":
        r"""__deepcopy__(PolyVector3 self, PyObject * memo) -> PolyVector3"""
        return _math_poly.PolyVector3___deepcopy__(self, memo)

    def __call__(self, *args) -> "PyObject *":
        r"""
        __call__(PolyVector3 self, double at) -> Vector3
        __call__(PolyVector3 self, PyObject * input) -> PyObject *
        """
        return _math_poly.PolyVector3___call__(self, *args)

    def asArray(self) -> "PyObject *":
        r"""asArray(PolyVector3 self) -> PyObject *"""
        return _math_poly.PolyVector3_asArray(self)

    @staticmethod
    def fromArray(array):
        return Poly1D(array.tolist())

    __swig_destroy__ = _math_poly.delete_PolyVector3

# Register PolyVector3 in _math_poly:
_math_poly.PolyVector3_swigregister(PolyVector3)

class StdVectorDouble(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(StdVectorDouble self) -> SwigPyIterator"""
        return _math_poly.StdVectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(StdVectorDouble self) -> bool"""
        return _math_poly.StdVectorDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(StdVectorDouble self) -> bool"""
        return _math_poly.StdVectorDouble___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        r"""__len__(StdVectorDouble self) -> std::vector< double >::size_type"""
        return _math_poly.StdVectorDouble___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        r"""__getslice__(StdVectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> std_vector_double"""
        return _math_poly.StdVectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(StdVectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(StdVectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, std_vector_double v)
        """
        return _math_poly.StdVectorDouble___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        r"""__delslice__(StdVectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _math_poly.StdVectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(StdVectorDouble self, std::vector< double >::difference_type i)
        __delitem__(StdVectorDouble self, PySliceObject * slice)
        """
        return _math_poly.StdVectorDouble___delitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        r"""pop(StdVectorDouble self) -> std::vector< double >::value_type"""
        return _math_poly.StdVectorDouble_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        r"""append(StdVectorDouble self, std::vector< double >::value_type const & x)"""
        return _math_poly.StdVectorDouble_append(self, x)

    def empty(self) -> "bool":
        r"""empty(StdVectorDouble self) -> bool"""
        return _math_poly.StdVectorDouble_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        r"""size(StdVectorDouble self) -> std::vector< double >::size_type"""
        return _math_poly.StdVectorDouble_size(self)

    def swap(self, v: "std_vector_double") -> "void":
        r"""swap(StdVectorDouble self, std_vector_double v)"""
        return _math_poly.StdVectorDouble_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        r"""begin(StdVectorDouble self) -> std::vector< double >::iterator"""
        return _math_poly.StdVectorDouble_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        r"""end(StdVectorDouble self) -> std::vector< double >::iterator"""
        return _math_poly.StdVectorDouble_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        r"""rbegin(StdVectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _math_poly.StdVectorDouble_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        r"""rend(StdVectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _math_poly.StdVectorDouble_rend(self)

    def clear(self) -> "void":
        r"""clear(StdVectorDouble self)"""
        return _math_poly.StdVectorDouble_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        r"""get_allocator(StdVectorDouble self) -> std::vector< double >::allocator_type"""
        return _math_poly.StdVectorDouble_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(StdVectorDouble self)"""
        return _math_poly.StdVectorDouble_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        r"""
        erase(StdVectorDouble self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(StdVectorDouble self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _math_poly.StdVectorDouble_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(StdVectorDouble self) -> StdVectorDouble
        __init__(StdVectorDouble self, std_vector_double other) -> StdVectorDouble
        __init__(StdVectorDouble self, std::vector< double >::size_type size) -> StdVectorDouble
        __init__(StdVectorDouble self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> StdVectorDouble
        """
        _math_poly.StdVectorDouble_swiginit(self, _math_poly.new_StdVectorDouble(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        r"""push_back(StdVectorDouble self, std::vector< double >::value_type const & x)"""
        return _math_poly.StdVectorDouble_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        r"""front(StdVectorDouble self) -> std::vector< double >::value_type const &"""
        return _math_poly.StdVectorDouble_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        r"""back(StdVectorDouble self) -> std::vector< double >::value_type const &"""
        return _math_poly.StdVectorDouble_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        r"""assign(StdVectorDouble self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _math_poly.StdVectorDouble_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(StdVectorDouble self, std::vector< double >::size_type new_size)
        resize(StdVectorDouble self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _math_poly.StdVectorDouble_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(StdVectorDouble self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(StdVectorDouble self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _math_poly.StdVectorDouble_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        r"""reserve(StdVectorDouble self, std::vector< double >::size_type n)"""
        return _math_poly.StdVectorDouble_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        r"""capacity(StdVectorDouble self) -> std::vector< double >::size_type"""
        return _math_poly.StdVectorDouble_capacity(self)

    def __getstate__(self):
    # Return a nonempty (thus non-false) tuple with dummy value in first position
        return (-1, tuple(pickle.dumps(elem) for elem in self))

    def __setstate__(self, state):
        self.__init__()
    # State will have a dummy entry in the first position
        for elem in state[1]:
            self.push_back(pickle.loads(elem))


    def __getitem__(self, *args) -> "double":
        r"""
        __getitem__(StdVectorDouble self, PySliceObject * slice) -> std_vector_double
        __getitem__(StdVectorDouble self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const
        __getitem__(StdVectorDouble self, long i) -> double
        """
        return _math_poly.StdVectorDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(StdVectorDouble self, PySliceObject * slice, std_vector_double v)
        __setitem__(StdVectorDouble self, PySliceObject * slice)
        __setitem__(StdVectorDouble self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        __setitem__(StdVectorDouble self, long i, double val)
        """
        return _math_poly.StdVectorDouble___setitem__(self, *args)

    def __str__(self) -> "std::string":
        r"""__str__(StdVectorDouble self) -> std::string"""
        return _math_poly.StdVectorDouble___str__(self)
    __swig_destroy__ = _math_poly.delete_StdVectorDouble

# Register StdVectorDouble in _math_poly:
_math_poly.StdVectorDouble_swigregister(StdVectorDouble)



