# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _sio_lite
else:
    import _sio_lite

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import coda.coda_sys
import coda.coda_io
import coda.coda_except
class FileHeader(object):
    r"""Proxy of C++ sio::lite::FileHeader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    UNSIGNED = _sio_lite.FileHeader_UNSIGNED
    
    SIGNED = _sio_lite.FileHeader_SIGNED
    
    FLOAT = _sio_lite.FileHeader_FLOAT
    
    COMPLEX_UNSIGNED = _sio_lite.FileHeader_COMPLEX_UNSIGNED
    
    COMPLEX_SIGNED = _sio_lite.FileHeader_COMPLEX_SIGNED
    
    COMPLEX_FLOAT = _sio_lite.FileHeader_COMPLEX_FLOAT
    
    N_BYTE_UNSIGNED = _sio_lite.FileHeader_N_BYTE_UNSIGNED
    
    N_BYTE_SIGNED = _sio_lite.FileHeader_N_BYTE_SIGNED
    
    BASIC_HEADER_LENGTH = _sio_lite.FileHeader_BASIC_HEADER_LENGTH
    

    def __init__(self, *args):
        r"""
        __init__(FileHeader self, int numLines, int numElements, int elementSize, int elementType, int ver=1) -> FileHeader
        __init__(FileHeader self) -> FileHeader
        """
        _sio_lite.FileHeader_swiginit(self, _sio_lite.new_FileHeader(*args))
    __swig_destroy__ = _sio_lite.delete_FileHeader

    def getLength(self) -> "long":
        r"""getLength(FileHeader self) -> long"""
        return _sio_lite.FileHeader_getLength(self)

    def getNumLines(self) -> "int":
        r"""getNumLines(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getNumLines(self)

    def setNumLines(self, numLines: "int") -> "void":
        r"""setNumLines(FileHeader self, int numLines)"""
        return _sio_lite.FileHeader_setNumLines(self, numLines)

    def getNumElements(self) -> "int":
        r"""getNumElements(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getNumElements(self)

    def setNumElements(self, numElements: "int") -> "void":
        r"""setNumElements(FileHeader self, int numElements)"""
        return _sio_lite.FileHeader_setNumElements(self, numElements)

    def getElementSize(self) -> "int":
        r"""getElementSize(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getElementSize(self)

    def setElementSize(self, size: "int") -> "void":
        r"""setElementSize(FileHeader self, int size)"""
        return _sio_lite.FileHeader_setElementSize(self, size)

    def getElementType(self) -> "int":
        r"""getElementType(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getElementType(self)

    def setElementType(self, type: "int") -> "void":
        r"""setElementType(FileHeader self, int type)"""
        return _sio_lite.FileHeader_setElementType(self, type)

    def getElementTypeAsString(self) -> "std::string":
        r"""getElementTypeAsString(FileHeader self) -> std::string"""
        return _sio_lite.FileHeader_getElementTypeAsString(self)

    def getVersion(self) -> "int":
        r"""getVersion(FileHeader self) -> int"""
        return _sio_lite.FileHeader_getVersion(self)

    def setVersion(self, newVersion: "int") -> "void":
        r"""setVersion(FileHeader self, int newVersion)"""
        return _sio_lite.FileHeader_setVersion(self, newVersion)

    def idsAreNullTerminated(self) -> "bool":
        r"""idsAreNullTerminated(FileHeader self) -> bool"""
        return _sio_lite.FileHeader_idsAreNullTerminated(self)

    def setNullTerminationFlag(self, flag: "bool") -> "void":
        r"""setNullTerminationFlag(FileHeader self, bool flag)"""
        return _sio_lite.FileHeader_setNullTerminationFlag(self, flag)

    def isDifferentByteOrdering(self) -> "bool":
        r"""isDifferentByteOrdering(FileHeader self) -> bool"""
        return _sio_lite.FileHeader_isDifferentByteOrdering(self)

    def setIsDifferentByteOrdering(self, isDifferent: "bool") -> "void":
        r"""setIsDifferentByteOrdering(FileHeader self, bool isDifferent)"""
        return _sio_lite.FileHeader_setIsDifferentByteOrdering(self, isDifferent)

    def userDataFieldExists(self, key: "std::string const &") -> "bool":
        r"""userDataFieldExists(FileHeader self, std::string const & key) -> bool"""
        return _sio_lite.FileHeader_userDataFieldExists(self, key)

    def getAllUserDataFields(self, keys: "std::vector< std::string > &") -> "void":
        r"""getAllUserDataFields(FileHeader self, std::vector< std::string > & keys)"""
        return _sio_lite.FileHeader_getAllUserDataFields(self, keys)

    def getNumUserDataFields(self) -> "size_t":
        r"""getNumUserDataFields(FileHeader self) -> size_t"""
        return _sio_lite.FileHeader_getNumUserDataFields(self)

    def getUserData(self, key: "std::string const &") -> "std::vector< sys::byte > &":
        r"""getUserData(FileHeader self, std::string const & key) -> std::vector< sys::byte > &"""
        return _sio_lite.FileHeader_getUserData(self, key)

    def getUserDataSection(self, *args) -> "sio::lite::UserDataDictionary &":
        r"""
        getUserDataSection(FileHeader self) -> sio::lite::UserDataDictionary const
        getUserDataSection(FileHeader self) -> sio::lite::UserDataDictionary &
        """
        return _sio_lite.FileHeader_getUserDataSection(self, *args)

    def addUserData(self, *args) -> "void":
        r"""
        addUserData(FileHeader self, std::string const & field, std::string const & data)
        addUserData(FileHeader self, std::string const & field, std::vector< sys::byte > const & data)
        addUserData(FileHeader self, std::string const & field, int data)
        """
        return _sio_lite.FileHeader_addUserData(self, *args)

    def to(self, numBands: "size_t", os: "OutputStream") -> "void":
        r"""to(FileHeader self, size_t numBands, OutputStream os)"""
        return _sio_lite.FileHeader_to(self, numBands, os)

# Register FileHeader in _sio_lite:
_sio_lite.FileHeader_swigregister(FileHeader)

class FileWriter(object):
    r"""Proxy of C++ sio::lite::FileWriter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(FileWriter self, std::string const & outputFile) -> FileWriter
        __init__(FileWriter self, char const * outputFile) -> FileWriter
        __init__(FileWriter self, OutputStream stream, bool adopt=True) -> FileWriter
        """
        _sio_lite.FileWriter_swiginit(self, _sio_lite.new_FileWriter(*args))
    __swig_destroy__ = _sio_lite.delete_FileWriter

    def write(self, *args) -> "void":
        r"""
        write(FileWriter self, FileHeader header, std::vector< io::InputStream * > bandStreams)
        write(FileWriter self, int numLines, int numElements, int elementSize, int elementType, std::vector< io::InputStream * > bandStreams)
        write(FileWriter self, FileHeader header, void const * data, int numBands=1)
        write(FileWriter self, int numLines, int numElements, int elementSize, int elementType, void const * data, int numBands=1)
        write(FileWriter self, FileHeader header, long long data)
        """
        return _sio_lite.FileWriter_write(self, *args)

# Register FileWriter in _sio_lite:
_sio_lite.FileWriter_swigregister(FileWriter)

AUTO = _sio_lite.AUTO

class StreamReader(coda.coda_io.InputStream):
    r"""Proxy of C++ sio::lite::StreamReader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_StreamReader

    def __init__(self, *args):
        r"""
        __init__(StreamReader self) -> StreamReader
        __init__(StreamReader self, InputStream _is, bool adopt=False) -> StreamReader
        """
        _sio_lite.StreamReader_swiginit(self, _sio_lite.new_StreamReader(*args))

    def setInputStream(self, _is: "InputStream", adopt: "bool"=False) -> "void":
        r"""setInputStream(StreamReader self, InputStream _is, bool adopt=False)"""
        return _sio_lite.StreamReader_setInputStream(self, _is, adopt)

    def getInputStream(self) -> "io::InputStream *":
        r"""getInputStream(StreamReader self) -> InputStream"""
        return _sio_lite.StreamReader_getInputStream(self)

    def getHeader(self, *args) -> "sio::lite::FileHeader const *":
        r"""
        getHeader(StreamReader self) -> FileHeader
        getHeader(StreamReader self) -> FileHeader
        """
        return _sio_lite.StreamReader_getHeader(self, *args)

    def readHeader(self) -> "sio::lite::FileHeader *":
        r"""readHeader(StreamReader self) -> FileHeader"""
        return _sio_lite.StreamReader_readHeader(self)

    def available(self) -> "sys::Off_T":
        r"""available(StreamReader self) -> sys::Off_T"""
        return _sio_lite.StreamReader_available(self)

    def read(self, data: "long long", size: "long long") -> "sys::SSize_T":
        r"""read(StreamReader self, long long data, long long size) -> sys::SSize_T"""
        return _sio_lite.StreamReader_read(self, data, size)

# Register StreamReader in _sio_lite:
_sio_lite.StreamReader_swigregister(StreamReader)

class FileReader(StreamReader, coda.coda_io.Seekable):
    r"""Proxy of C++ sio::lite::FileReader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _sio_lite.delete_FileReader

    def __init__(self, *args):
        r"""
        __init__(FileReader self) -> FileReader
        __init__(FileReader self, std::string const & file) -> FileReader
        __init__(FileReader self, io::FileInputStream * _is, bool adopt=False) -> FileReader
        """
        _sio_lite.FileReader_swiginit(self, _sio_lite.new_FileReader(*args))

    def seek(self, offset: "sys::Off_T", whence: "io::Seekable::Whence") -> "sys::Off_T":
        r"""seek(FileReader self, sys::Off_T offset, io::Seekable::Whence whence) -> sys::Off_T"""
        return _sio_lite.FileReader_seek(self, offset, whence)

    def tell(self) -> "sys::Off_T":
        r"""tell(FileReader self) -> sys::Off_T"""
        return _sio_lite.FileReader_tell(self)

    def killStream(self) -> "void":
        r"""killStream(FileReader self)"""
        return _sio_lite.FileReader_killStream(self)

# Register FileReader in _sio_lite:
_sio_lite.FileReader_swigregister(FileReader)


import numpy

def dtypeFromSioType(elementType, elementSize):
    """
    Convert an SIO type & size to a NumPy dtype
    Complex integer types are not supported
    """
    typeMap = {FileHeader.UNSIGNED: 'uint',
               FileHeader.SIGNED: 'int',
               FileHeader.FLOAT: 'float',
               FileHeader.COMPLEX_FLOAT: 'complex'}

    if not elementType in typeMap:
        raise Exception("Unknown element type: " + str(elementType))

    dtypeStr = "%s%s" % (typeMap[elementType], elementSize * 8)

    return numpy.dtype(dtypeStr)


def sioTypeFromDtype(dtype):
    """
    Convert a NumPy dtype into an SIO type & size
    """
# Handle dtypes, strings, numpy types
    dt = numpy.dtype(dtype)

    kindToType = {'i': FileHeader.SIGNED,
                  'u': FileHeader.UNSIGNED,
                  'f': FileHeader.FLOAT,
                  'c': FileHeader.COMPLEX_FLOAT}

    if not dt.kind in kindToType:
        raise Exception("Unknown element type: " + str(dt.kind))

    return kindToType[dt.kind]


def write(numpyArray, outputPathname, elementType = None):
# Make sure this array is sized properly
    if len(numpyArray.shape) != 2:
        raise Exception("Only 2 dimensional images are supported")
    if elementType is None:
        elementType = numpyArray.dtype

    if type(elementType) != int:
        elementType = sioTypeFromDtype(elementType)

    if not numpyArray.flags['C_CONTIGUOUS']:
        numpyArray = numpy.ascontiguousarray(numpyArray)

    header = FileHeader(numpyArray.shape[0],
                        numpyArray.shape[1],
                        numpyArray.strides[1],
                        elementType);

    pointer, ro = numpyArray.__array_interface__['data']

    if pointer == 0 or pointer == None:
        raise Exception("Attempting to write a NULL image")

    writer = FileWriter(outputPathname)
    writer.write(header, pointer)


def read(inputPathname):
    reader = FileReader(inputPathname)
    header = reader.getHeader()

    elementSize = header.getElementSize()
    dtype = dtypeFromSioType(header.getElementType(), elementSize)

    numpyArray = numpy.empty(shape = (header.getNumLines(),
                                      header.getNumElements()),
                             dtype = dtype)
    pointer, ro = numpyArray.__array_interface__['data']
    reader.read(pointer, numpyArray.shape[0] * numpyArray.shape[1] * elementSize)
    return numpyArray;



